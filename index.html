<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Cyberpunk Graph Visualizer — Dijkstra & Kruskal</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#05030a; --panel:#0b0b17; --neon-cyan:#00ffe1; --neon-pink:#ff4df0; --neon-green:#7bff6b; --neon-orange:#ffb85c; --neon-red:#ff5370;
  --muted:#9aa7b2;
}
html,body{height:100%;margin:0;background:linear-gradient(180deg,#030312 0%,#060316 100%);font-family:Orbitron,system-ui,Arial;color:var(--neon-cyan);}
.app{display:grid;grid-template-columns:380px 1fr;gap:18px;padding:18px;height:100vh;box-sizing:border-box}
.panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03)}
.sidebar{display:flex;flex-direction:column;gap:10px}
label{font-size:13px;color:var(--muted)}
select, button, input[type=range]{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px;border-radius:8px;color:var(--neon-cyan);outline:none}
button{cursor:pointer}
button:hover{box-shadow:0 0 12px rgba(0,255,225,0.06);transform:translateY(-2px)}
#legend{font-size:13px;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;color:var(--muted)}
.legend-item{display:flex;align-items:center;gap:8px;margin:6px 0}
.color-box{width:18px;height:14px;border-radius:4px;border:1px solid rgba(255,255,255,0.05)}
#explain{height:260px;overflow:auto;background:rgba(0,0,0,0.25);padding:8px;border-radius:8px;font-family:monospace;color:#bdebbd}
#canvasWrap{border-radius:12px;overflow:hidden;position:relative;background:linear-gradient(180deg,#020214,#050117)}
canvas{display:block;width:100%;height:100%}
.controls-row{display:flex;gap:8px;align-items:center}
.small{font-size:12px;color:var(--muted)}
footer{font-size:12px;color:var(--muted);margin-top:6px}
@media (max-width:980px){ .app{grid-template-columns:1fr;grid-auto-rows:auto} }
</style>
</head>
<body>
<div class="app">
  <div class="panel sidebar">
    <h2 style="margin:0 0 6px 0;color:var(--neon-pink)">⚡ Cyberpunk Graph Visualizer</h2>

    <div>
      <label>Mode</label><br/>
      <select id="mode"><option value="move">Move</option><option value="add">Add Node</option><option value="edge">Add Edge</option><option value="delete">Delete Node</option></select>
    </div>

    <div>
      <label>Algorithm</label><br/>
      <select id="algorithm"><option value="dijkstra">Dijkstra (shortest)</option><option value="kruskal">Kruskal (MST)</option></select>
    </div>

    <div id="dijkstraOptions">
      <label>Start</label><br/><select id="startNode"></select>
      <label>End</label><br/><select id="endNode"></select>
    </div>

    <div>
      <label>Presets (new random on each Load)</label><br/>
      <select id="preset">
        <option value="">-- choose preset --</option>
        <option value="triangle">Triangle</option>
        <option value="square">Square</option>
        <option value="chain">Weighted Chain</option>
        <option value="random">Random (new each load)</option>
        <option value="star">Star</option>
        <option value="complete">Complete (n=6)</option>
        <option value="hexagon">Hexagon</option>
      </select>
      <div style="margin-top:8px" class="controls-row">
        <button id="loadPresetBtn">Load</button>
        <button id="clearBtn">Clear</button>
      </div>
    </div>

    <div class="controls-row" style="margin-top:6px">
      <button id="setupBtn">Setup</button>
      <button id="stepBtn">Step</button>
      <button id="playBtn">Play</button>
    </div>

    <div style="margin-top:6px">
      <label>Speed (ms)</label><br/>
      <input id="speed" type="range" min="200" max="2000" step="100" value="900">
      <div class="small">Current: <span id="speedVal">900</span> ms</div>
    </div>

    <div style="margin-top:6px">
      <button id="showFullBtn">Show Full Shortest (instant)</button>
    </div>

    <div id="legend" style="margin-top:10px">
      <strong style="color:var(--neon-pink)">Legend</strong>
      <div class="legend-item"><span class="color-box" style="background:cyan"></span> Unvisited Node</div>
      <div class="legend-item"><span class="color-box" style="background:var(--neon-orange)"></span> Medium Path (Dijkstra)</div>
      <div class="legend-item"><span class="color-box" style="background:var(--neon-red)"></span> Longest Path (Dijkstra)</div>
      <div class="legend-item"><span class="color-box" style="background:var(--neon-green)"></span> Shortest Path or Accepted Edge</div>
      <div class="legend-item"><span class="color-box" style="background:#888"></span> Normal Edge</div>
    </div>

    <div style="margin-top:10px">
      <div style="font-size:13px;color:var(--muted)">Explanation / Log</div>
      <div id="explain"></div>
    </div>

    <footer>Use small graphs for full path enumeration during demo (MAX 2000 paths)</footer>
  </div>

  <div id="canvasWrap" class="panel">
    <canvas id="c"></canvas>
  </div>
</div>

<script>
// ---------------------- constants & canvas ----------------------
const canvas = document.getElementById('c'), ctx = canvas.getContext('2d');
function resizeCanvas(){
  canvas.width = document.getElementById('canvasWrap').clientWidth;
  canvas.height = window.innerHeight - 36;
  drawGraph();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const NODE_RADIUS = 22;
const MAX_PATHS = 2000; // safety cap for enumeration

// ---------------------- graph state ----------------------
let nodes = {};      // label -> [x,y]
let edges = {};      // label -> [{v:other, w:weight}, ...]
let nodeCount = 0;
let mode = 'add';                // add, edge, move, delete
let selectedForEdge = null;
let dragging = null;
let dragOffset = null;

// kruskal generator state
let kruskalGen = null;
let playInterval = null;
// For showFullPath
let lastPrev = null;

// ---------------------- UI refs ----------------------
const modeSel = document.getElementById('mode');
const algoSel = document.getElementById('algorithm');
const startSel = document.getElementById('startNode');
const endSel = document.getElementById('endNode');
const presetSel = document.getElementById('preset');
const loadPresetBtn = document.getElementById('loadPresetBtn');
const clearBtn = document.getElementById('clearBtn');
const setupBtn = document.getElementById('setupBtn');
const stepBtn = document.getElementById('stepBtn');
const playBtn = document.getElementById('playBtn');
const showFullBtn = document.getElementById('showFullBtn');
const explainBox = document.getElementById('explain');
const speedRange = document.getElementById('speed');
const speedVal = document.getElementById('speedVal');

modeSel.addEventListener('change', ()=> mode = modeSel.value);
speedRange.addEventListener('input', ()=> speedVal.innerText = speedRange.value);

loadPresetBtn.addEventListener('click', ()=> loadPreset(presetSel.value));
clearBtn.addEventListener('click', resetGraph);
setupBtn.addEventListener('click', setupRun);
stepBtn.addEventListener('click', stepOnce);
playBtn.addEventListener('click', togglePlay);
showFullBtn.addEventListener('click', showFullPath);

canvas.addEventListener('click', onCanvasClick);
canvas.addEventListener('mousedown', onMouseDown);
canvas.addEventListener('mousemove', onMouseMove);
window.addEventListener('mouseup', onMouseUp);

// ---------------------- drawing ----------------------
function drawGraph(highlights={node:{}, edge:{}}){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.lineWidth = 3;
  ctx.textAlign = 'center'; ctx.textBaseline='middle'; ctx.font='14px monospace';

  // draw edges (once each direction; highlights keyed by 'u-v')
  for(const u in edges){
    for(const e of edges[u]){
      const v = e.v;
      // draw line
      const key = `${u}-${v}`;
      const col = highlights.edge && highlights.edge[key] ? highlights.edge[key] : '#888';
      ctx.strokeStyle = col;
      ctx.shadowBlur = (col==='lime' || col==='var(--neon-green)') ? 12 : (col==='red'?6:0);
      ctx.beginPath();
      const [x1,y1] = nodes[u], [x2,y2] = nodes[v];
      ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.shadowBlur = 0;
      // weight label
      ctx.fillStyle = '#ffd66b';
      ctx.fillText(e.w, (x1+x2)/2, (y1+y2)/2 - 12);
    }
  }

  // draw nodes
  for(const id in nodes){
    const [x,y] = nodes[id];
    const fill = highlights.node && highlights.node[id] ? highlights.node[id] : 'cyan';
    ctx.beginPath();
    ctx.fillStyle = fill; ctx.strokeStyle='#000'; ctx.lineWidth = 2;
    ctx.arc(x,y,NODE_RADIUS,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#071322'; ctx.font='bold 14px monospace'; ctx.fillText(id, x, y);
  }
}

// ---------------------- utilities ----------------------
function uid(){ return String.fromCharCode(65 + nodeCount); }
function addNodeAt(x,y,label=null){ const id = label || uid(); if(!label) nodeCount++; nodes[id] = [x,y]; edges[id] = edges[id] || []; updateSelectors(); drawGraph(); }
function removeNode(id){ if(!nodes[id]) return; delete nodes[id]; delete edges[id]; for(const u in edges) edges[u] = edges[u].filter(e=> e.v !== id); updateSelectors(); drawGraph(); }
function addEdge(u,v,w){ if(!edges[u]) edges[u]=[]; if(!edges[v]) edges[v]=[]; if(!edges[u].some(e=>e.v===v)) edges[u].push({v,w}); if(!edges[v].some(e=>e.v===u)) edges[v].push({v,w}); drawGraph(); }
function findNodeAt(x,y){ for(const id in nodes){ const [nx,ny]=nodes[id]; if(Math.hypot(nx-x,ny-y) <= NODE_RADIUS) return id; } return null; }
function updateSelectors(){ startSel.innerHTML=''; endSel.innerHTML=''; const keys = Object.keys(nodes).sort(); for(const k of keys){ const o1=document.createElement('option'); o1.value=k; o1.textContent=k; startSel.appendChild(o1); const o2=o1.cloneNode(true); endSel.appendChild(o2); } }

// ---------------------- canvas interactions ----------------------
function onCanvasClick(ev){
  const rect = canvas.getBoundingClientRect();
  const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
  if(mode === 'add'){
    addNodeAt(x,y);
  } else if(mode === 'edge'){
    const node = findNodeAt(x,y);
    if(!node) return;
    if(!selectedForEdge){ selectedForEdge = node; flashNode(node, 'var(--neon-orange)'); log(`Selected ${node} as endpoint 1`); }
    else if(selectedForEdge === node){ log('Cannot connect node to itself'); selectedForEdge = null; drawGraph(); }
    else {
      const w = prompt(`Weight for edge ${selectedForEdge} ↔ ${node}`, '1');
      const ww = Math.max(1, Number(w) || 1);
      addEdge(selectedForEdge, node, ww);
      log(`Added edge ${selectedForEdge} ↔ ${node} (w=${ww})`);
      selectedForEdge = null;
    }
  } else if(mode === 'delete'){
    const node = findNodeAt(x,y); if(node){ removeNode(node); log(`Deleted node ${node}`); }
  }
}
function onMouseDown(ev){
  if(mode !== 'move') return;
  const rect = canvas.getBoundingClientRect();
  const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
  const node = findNodeAt(x,y);
  if(node){ dragging = node; dragOffset = [x - nodes[node][0], y - nodes[node][1]]; }
}
function onMouseMove(ev){
  if(!dragging) return;
  const rect = canvas.getBoundingClientRect();
  const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
  nodes[dragging][0] = x - dragOffset[0]; nodes[dragging][1] = y - dragOffset[1];
  drawGraph();
}
function onMouseUp(ev){ dragging = null; dragOffset = null; }

// small visual helper
function flashNode(id, color='orange', ms=500){ drawGraph({node:{[id]:color}}); setTimeout(()=>drawGraph(), ms); }
function log(s){ explainBox.innerHTML += '• ' + s + '<br>'; explainBox.scrollTop = explainBox.scrollHeight; }
function clearLog(){ explainBox.innerHTML=''; }

// ---------------------- Dijkstra core + all-paths enumeration ----------------------
function computeDijkstra(start, end){
  const dist = {}, prev = {};
  for(const n in nodes){ dist[n] = Infinity; prev[n] = null; }
  dist[start] = 0;
  const heap = [[0,start]];
  while(heap.length){
    heap.sort((a,b)=>a[0]-b[0]);
    const [d,u] = heap.shift();
    if(d > dist[u]) continue;
    if(u === end) break;
    for(const e of edges[u] || []){
      const v = e.v, w = e.w;
      if(dist[u] + w < dist[v]){ dist[v] = dist[u] + w; prev[v] = u; heap.push([dist[v], v]); }
    }
  }
  return {dist, prev};
}

// enumerate simple paths with DFS, capped
function enumerateAllSimplePaths(start, end){
  const results = []; const visited = new Set(); const path = [];
  function dfs(u){
    if(results.length >= MAX_PATHS) return;
    visited.add(u); path.push(u);
    if(u === end){
      // compute weight
      let total = 0;
      for(let i=0;i+1<path.length;i++){
        const a = path[i], b = path[i+1];
        const e = edges[a].find(x=>x.v===b);
        total += e ? e.w : Infinity;
      }
      if(isFinite(total)) results.push({nodes:[...path], weight: total});
    } else {
      for(const e of edges[u] || []){
        if(!visited.has(e.v)) dfs(e.v);
        if(results.length >= MAX_PATHS) break;
      }
    }
    path.pop(); visited.delete(u);
  }
  dfs(start);
  return results;
}
function pickLMS(paths){
  if(!paths.length) return {long:null, mid:null, short:null};
  const arr = paths.slice().sort((a,b)=>b.weight - a.weight); // desc
  const longest = arr[0];
  const shortest = arr[arr.length-1];
  const mid = arr[Math.floor(arr.length/2)] || arr[0];
  return {long:longest, mid:mid, short:shortest};
}

function drawPathHighlights(nodeList, color){
  const hl = {node:{}, edge:{}};
  for(const n of nodeList) hl.node[n] = color;
  for(let i=0;i+1<nodeList.length;i++){
    const a = nodeList[i], b = nodeList[i+1];
    hl.edge[`${a}-${b}`] = color; hl.edge[`${b}-${a}`] = color;
  }
  drawGraph(hl);
}

function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

async function highlightOnePath(nodeList, color, showMs){
  drawPathHighlights(nodeList, color);
  await sleep(showMs + 200);
}

async function animatePathSequence(picks){
  const delay = Math.max(300, parseInt(speedRange.value)||900);
  drawGraph(); await sleep(300);
  if(picks.long){ log(`Showing Longest (weight=${picks.long.weight})`); await highlightOnePath(picks.long.nodes, 'red', delay); }
  if(picks.mid){ log(`Showing Medium (weight=${picks.mid.weight})`); await highlightOnePath(picks.mid.nodes, 'orange', delay); }
  if(picks.short){ log(`Showing Shortest (weight=${picks.short.weight})`); await highlightOnePath(picks.short.nodes, 'lime', delay); }
  lastPrev = null; // not storing prev here; showFull uses recompute
  log('Sequence complete — shortest remains highlighted.');
}

// ---------------------- Kruskal (generator for stepping) ----------------------
function* kruskalGenerator(){
  const all = [];
  for(const u in edges){ for(const e of edges[u]){ if(u < e.v) all.push({u, v: e.v, w: e.w}); } }
  all.sort((a,b)=>a.w-b.w);
  const parent = {}, rank = {};
  for(const n in nodes){ parent[n]=n; rank[n]=0; }
  function find(x){ return parent[x]===x ? x : (parent[x] = find(parent[x])); }
  function unite(a,b){
    a = find(a); b = find(b); if(a===b) return false;
    if(rank[a] < rank[b]) [a,b] = [b,a];
    parent[b] = a; if(rank[a]===rank[b]) rank[a]++; return true;
  }
  for(const e of all){
    yield {type:'consider', edge:e};
    if(unite(e.u, e.v)) yield {type:'accept', edge:e};
    else yield {type:'reject', edge:e};
  }
  yield {type:'done'};
}

// ---------------------- flow controls ----------------------
async function setupRun(){
  clearLog();
  const algo = algoSel.value;
  if(algo === 'dijkstra'){
    const start = startSel.value, end = endSel.value;
    if(!start || !end){ log('Choose Start and End nodes'); return; }
    log(`Dijkstra: enumerating paths from ${start} to ${end} (cap ${MAX_PATHS})`);
    const paths = enumerateAllSimplePaths(start, end);
    if(paths.length === 0){ log('No path exists'); return; }
    if(paths.length >= MAX_PATHS) log(`Path count capped at ${MAX_PATHS} — results partial`);
    const picks = pickLMS(paths);
    log(`Found ${paths.length} path(s). Long=${picks.long? picks.long.weight:'N/A'} Mid=${picks.mid? picks.mid.weight:'N/A'} Short=${picks.short? picks.short.weight:'N/A'}`);
    await animatePathSequence(picks);
  } else {
    // Kruskal: prepare generator, initial draw
    kruskalGen = kruskalGenerator();
    drawGraph();
    log('Kruskal ready — use Step or Play to run MST construction.');
  }
}

async function stepOnce(){
  const algo = algoSel.value;
  if(algo === 'dijkstra'){ log('Dijkstra runs as a full visualization after Setup — use Setup to run it.'); return; }
  if(!kruskalGen){ kruskalGen = kruskalGenerator(); }
  const nxt = kruskalGen.next();
  if(nxt.done){ log('Kruskal finished'); kruskalGen = null; return; }
  const v = nxt.value;
  if(v.type === 'consider'){ log(`Considering ${v.edge.u}-${v.edge.v} (w=${v.edge.w})`); drawGraph({edge:{[`${v.edge.u}-${v.edge.v}`]:'#ffb85c',[`${v.edge.v}-${v.edge.u}`]:'#ffb85c'}}); }
  else if(v.type === 'accept'){ log(`Accepted ${v.edge.u}-${v.edge.v}`); drawGraph({edge:{[`${v.edge.u}-${v.edge.v}`]:'lime',[`${v.edge.v}-${v.edge.u}`]:'lime'}}); }
  else if(v.type === 'reject'){ log(`Rejected ${v.edge.u}-${v.edge.v} (cycle)`); drawGraph({edge:{[`${v.edge.u}-${v.edge.v}`]:'red',[`${v.edge.v}-${v.edge.u}`]:'red'}}); }
}

function togglePlay(){
  if(playInterval){ clearInterval(playInterval); playInterval = null; playBtn.textContent = 'Play'; log('Paused autoplay'); }
  else {
    if(algoSel.value === 'dijkstra'){ log('Play is for Kruskal stepping. Use Setup for Dijkstra full visualization.'); return; }
    playBtn.textContent = 'Pause';
    playInterval = setInterval(()=> stepOnce(), Math.max(150, parseInt(speedRange.value)));
    log('Autoplay Kruskal started');
  }
}

// Instant show shortest path (recompute prev and highlight)
function showFullPath(){
  if(algoSel.value !== 'dijkstra'){ log('Show Full Shortest only for Dijkstra'); return; }
  const start = startSel.value, end = endSel.value;
  if(!start || !end){ log('Select start & end'); return; }
  const {dist, prev} = computeDijkstra(start, end);
  if(!isFinite(dist[end])){ log('No path'); return; }
  // reconstruct shortest path
  const lst = [];
  let cur = end;
  while(cur){ lst.push(cur); cur = prev[cur]; if(!cur) break; if(lst.length>200) break; } // safety
  lst.reverse();
  drawPathHighlights(lst, 'lime');
  log('Shortest path highlighted instantly.');
}

// reset
function resetGraph(){
  nodes = {}; edges = {}; nodeCount = 0; selectedForEdge = null; kruskalGen = null; lastPrev = null;
  clearLog(); updateSelectors(); drawGraph();
}

// ---------------------- presets ----------------------
function loadPreset(which){
  resetGraph();
  const cx = canvas.width/2, cy = canvas.height/2;
  if(which === 'triangle'){
    nodes = {A:[cx-120,cy+60], B:[cx,cy-90], C:[cx+120,cy+60]}; edges = {A:[{v:'B',w:4},{v:'C',w:1}], B:[{v:'A',w:4},{v:'C',w:2}], C:[{v:'A',w:1},{v:'B',w:2}]}; nodeCount=3;
  } else if(which === 'square'){
    nodes = {A:[cx-140,cy-90], B:[cx+140, cy-90], C:[cx+140, cy+90], D:[cx-140, cy+90]};
    edges = {A:[{v:'B',w:3},{v:'D',w:1}], B:[{v:'A',w:3},{v:'C',w:4}], C:[{v:'B',w:4},{v:'D',w:2}], D:[{v:'A',w:1},{v:'C',w:2}]}; nodeCount=4;
  } else if(which === 'chain'){
    nodes = {A:[cx-280,cy], B:[cx-100,cy], C:[cx+80,cy], D:[cx+260,cy]};
    edges = {A:[{v:'B',w:5}], B:[{v:'A',w:5},{v:'C',w:3}], C:[{v:'B',w:3},{v:'D',w:6}], D:[{v:'C',w:6}]}; nodeCount=4;
  } else if(which === 'random'){
    nodes = {}; edges = {}; nodeCount = 0;
    const N = 6 + Math.floor(Math.random()*3); // 6-8 nodes
    for(let i=0;i<N;i++){
      const n = String.fromCharCode(65 + nodeCount++);
      const ang = i * (Math.PI*2/N);
      nodes[n] = [cx + Math.cos(ang)*170 + (Math.random()-0.5)*40, cy + Math.sin(ang)*120 + (Math.random()-0.5)*40];
      edges[n] = [];
    }
    const keys = Object.keys(nodes);
    for(let i=0;i<keys.length;i++){
      for(let j=i+1;j<keys.length;j++){
        if(Math.random() < 0.45){
          const w = Math.floor(Math.random()*9)+1;
          edges[keys[i]].push({v:keys[j], w}); edges[keys[j]].push({v:keys[i], w});
        }
      }
    }
  } else if(which === 'star'){
    nodes={}; edges={}; nodeCount=0;
    nodes['A']=[cx,cy]; edges['A']=[]; nodeCount=1;
    for(let i=0;i<6;i++){
      const n = String.fromCharCode(65 + nodeCount++);
      nodes[n]=[cx + Math.cos(i*(Math.PI*2/6))*180, cy + Math.sin(i*(Math.PI*2/6))*120]; edges[n]=[];
      const w = Math.floor(Math.random()*8)+1;
      edges['A'].push({v:n,w}); edges[n].push({v:'A',w});
    }
  } else if(which === 'complete'){
    nodes={}; edges={}; nodeCount=0;
    const N = 6;
    for(let i=0;i<N;i++){ const n=String.fromCharCode(65+nodeCount++); nodes[n]=[cx+Math.cos(i*2*Math.PI/N)*160, cy+Math.sin(i*2*Math.PI/N)*120]; edges[n]=[]; }
    const keys=Object.keys(nodes);
    for(let i=0;i<keys.length;i++){ for(let j=i+1;j<keys.length;j++){ const w=Math.floor(Math.random()*9)+1; edges[keys[i]].push({v:keys[j],w}); edges[keys[j]].push({v:keys[i],w}); } }
  } else if(which === 'hexagon'){
    nodes={}; edges={}; nodeCount=0;
    for(let i=0;i<6;i++){ const n=String.fromCharCode(65+nodeCount++); const ang=i*(Math.PI*2/6); nodes[n]=[cx+Math.cos(ang)*170,cy+Math.sin(ang)*120]; edges[n]=[]; }
    const keys=Object.keys(nodes);
    for(let i=0;i<keys.length;i++){ const a=keys[i], b=keys[(i+1)%keys.length]; const w=Math.floor(Math.random()*9)+1; edges[a].push({v:b,w}); edges[b].push({v:a,w}); }
  }
  updateSelectors(); drawGraph(); log(`Loaded preset: ${which}`);
}

// ------------------- initialize -------------------
presetSel.value='triangle'; loadPreset('triangle');

// expose some helpers for debugging (optional)
// window._gv = { nodes, edges, drawGraph };

</script>
</body>
</html>






