<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Cyberpunk Graph Visualizer — Fixed Presets & Selectors</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
<style>
:root{
  --neon-cyan:#00ffe1; --neon-pink:#ff4df0; --neon-green:#7bff6b; --neon-orange:#ffb85c; --neon-red:#ff5370;
  --muted:#9aa7b2;
}
html,body{height:100%;margin:0;background:linear-gradient(180deg,#030312 0%,#060316 100%);font-family:Orbitron,Arial,monospace;color:var(--neon-cyan);}
.app{display:grid;grid-template-columns:380px 1fr;gap:18px;padding:18px;height:100vh;box-sizing:border-box}
.panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03)}
.sidebar{display:flex;flex-direction:column;gap:10px}
label{font-size:13px;color:var(--muted)}
select, button, input[type=range]{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px;border-radius:8px;color:var(--neon-cyan);outline:none}
button{cursor:pointer}
button:hover{box-shadow:0 0 12px rgba(0,255,225,0.06);transform:translateY(-2px)}
#legend{font-size:13px;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;color:var(--muted)}
.legend-item{display:flex;align-items:center;gap:8px;margin:6px 0}
.color-box{width:18px;height:14px;border-radius:4px;border:1px solid rgba(255,255,255,0.05)}
#explain{height:260px;overflow:auto;background:rgba(0,0,0,0.25);padding:8px;border-radius:8px;font-family:monospace;color:#bdebbd}
#canvasWrap{border-radius:12px;overflow:hidden;position:relative;background:linear-gradient(180deg,#020214,#050117)}
canvas{display:block;width:100%;height:100%}
.controls-row{display:flex;gap:8px;align-items:center}
.small{font-size:12px;color:var(--muted)}
footer{font-size:12px;color:var(--muted);margin-top:6px}
@media (max-width:980px){ .app{grid-template-columns:1fr;grid-auto-rows:auto} }
</style>
</head>
<body>
<div class="app">
  <div class="panel sidebar">
    <h2 style="margin:0 0 6px 0;color:var(--neon-pink)">⚡ Cyberpunk Graph Visualizer</h2>

    <div>
      <label>Mode</label><br/>
      <select id="mode"><option value="move">Move</option><option value="add">Add Node</option><option value="edge">Add Edge</option><option value="delete">Delete Node</option></select>
    </div>

    <div>
      <label>Algorithm</label><br/>
      <select id="algorithm"><option value="dijkstra">Dijkstra (shortest)</option><option value="kruskal">Kruskal (MST)</option></select>
    </div>

    <div id="dijkstraOptions">
      <label>Start</label><br/><select id="startNode"></select>
      <label>End</label><br/><select id="endNode"></select>
    </div>

    <div>
      <label>Presets (random graph is new every Load)</label><br/>
      <select id="preset">
        <option value="">-- choose preset --</option>
        <option value="triangle">Triangle</option>
        <option value="square">Square</option>
        <option value="chain">Weighted Chain</option>
        <option value="random">Random (new each load)</option>
        <option value="star">Star</option>
        <option value="complete">Complete (n=6)</option>
        <option value="hexagon">Hexagon</option>
      </select>
      <div style="margin-top:8px" class="controls-row">
        <button id="loadPresetBtn">Load</button>
        <button id="clearBtn">Clear</button>
      </div>
    </div>

    <div class="controls-row" style="margin-top:6px">
      <button id="setupBtn">Setup</button>
      <button id="stepBtn">Step</button>
      <button id="playBtn">Play</button>
    </div>

    <div style="margin-top:6px">
      <label>Speed (ms)</label><br/>
      <input id="speed" type="range" min="200" max="2000" step="100" value="900">
      <div class="small">Current: <span id="speedVal">900</span> ms</div>
    </div>

    <div style="margin-top:6px">
      <button id="showFullBtn">Show Full Shortest (instant)</button>
    </div>

    <div id="legend" style="margin-top:10px">
      <strong style="color:var(--neon-pink)">Legend</strong>
      <div class="legend-item"><span class="color-box" style="background:cyan"></span> Unvisited Node</div>
      <div class="legend-item"><span class="color-box" style="background:var(--neon-orange)"></span> Medium Path (Dijkstra)</div>
      <div class="legend-item"><span class="color-box" style="background:var(--neon-red)"></span> Longest Path (Dijkstra)</div>
      <div class="legend-item"><span class="color-box" style="background:var(--neon-green)"></span> Shortest Path or Accepted Edge</div>
      <div class="legend-item"><span class="color-box" style="background:#888"></span> Normal Edge</div>
    </div>

    <div style="margin-top:10px">
      <div style="font-size:13px;color:var(--muted)">Explanation / Log</div>
      <div id="explain"></div>
    </div>

    <footer>Use small graphs for full path enumeration during demo (MAX 2000 paths)</footer>
  </div>

  <div id="canvasWrap" class="panel">
    <canvas id="c"></canvas>
  </div>
</div>

<script>
// ---------- setup ----------
const canvas = document.getElementById('c'), ctx = canvas.getContext('2d');
function resizeCanvas(){ canvas.width = document.getElementById('canvasWrap').clientWidth; canvas.height = window.innerHeight - 36; drawGraph(); }
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const NODE_RADIUS = 22;
const MAX_PATHS = 2000;

let nodes = {};    // label -> [x,y]
let edges = {};    // label -> [{v:other, w:weight}, ...]
let mode = 'add';
let selectedForEdge = null;
let dragging = null, dragOffset = null;
let kruskalGen = null, playInterval = null;

// UI refs
const modeSel = document.getElementById('mode');
const algoSel = document.getElementById('algorithm');
const startSel = document.getElementById('startNode');
const endSel = document.getElementById('endNode');
const presetSel = document.getElementById('preset');
const loadPresetBtn = document.getElementById('loadPresetBtn');
const clearBtn = document.getElementById('clearBtn');
const setupBtn = document.getElementById('setupBtn');
const stepBtn = document.getElementById('stepBtn');
const playBtn = document.getElementById('playBtn');
const showFullBtn = document.getElementById('showFullBtn');
const explainBox = document.getElementById('explain');
const speedRange = document.getElementById('speed');
const speedVal = document.getElementById('speedVal');

modeSel.addEventListener('change', ()=> mode = modeSel.value);
speedRange.addEventListener('input', ()=> speedVal.innerText = speedRange.value);

loadPresetBtn.addEventListener('click', ()=> loadPreset(presetSel.value));
clearBtn.addEventListener('click', resetGraph);
setupBtn.addEventListener('click', setupRun);
stepBtn.addEventListener('click', stepOnce);
playBtn.addEventListener('click', togglePlay);
showFullBtn.addEventListener('click', showFullPath);

canvas.addEventListener('click', onCanvasClick);
canvas.addEventListener('mousedown', onMouseDown);
canvas.addEventListener('mousemove', onMouseMove);
window.addEventListener('mouseup', onMouseUp);

// ---------- drawing ----------
function drawGraph(highlights={node:{}, edge:{}}){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.lineWidth = 3;
  ctx.textAlign = 'center'; ctx.textBaseline='middle'; ctx.font='14px monospace';

  // Draw edges once (u < v) to avoid duplicates:
  for(const u in edges){
    if(!(u in nodes)) continue;
    for(const e of edges[u]){
      const v = e.v;
      if(!(v in nodes)) continue;
      if(u > v) continue; // draw once
      // pick highlight color if present in either direction
      const key1 = `${u}-${v}`, key2 = `${v}-${u}`;
      const col = (highlights.edge && (highlights.edge[key1] || highlights.edge[key2])) ? (highlights.edge[key1] || highlights.edge[key2]) : '#888';
      ctx.strokeStyle = col;
      ctx.shadowBlur = (col === 'lime') ? 12 : (col === 'red' ? 6 : 0);
      const [x1,y1] = nodes[u], [x2,y2] = nodes[v];
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#ffd66b';
      ctx.fillText(e.w, (x1+x2)/2, (y1+y2)/2 - 12);
    }
  }

  // Draw nodes
  for(const id in nodes){
    const [x,y] = nodes[id];
    const fill = (highlights.node && highlights.node[id]) ? highlights.node[id] : 'cyan';
    ctx.beginPath(); ctx.fillStyle = fill; ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
    ctx.arc(x,y,NODE_RADIUS,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#071322'; ctx.font='bold 14px monospace'; ctx.fillText(id, x, y);
  }
}

// ---------- utilities ----------
function getNextLabel(){
  for(let i=0;i<26;i++){
    const c = String.fromCharCode(65+i);
    if(!(c in nodes)) return c;
  }
  // fallback
  let i = 0;
  while(true){ const c = 'N' + i++; if(!(c in nodes)) return c; }
}
function addNodeAt(x,y,label=null){
  const id = label || getNextLabel();
  nodes[id] = [x,y];
  edges[id] = edges[id] || [];
  updateSelectors();
  drawGraph();
}
function removeNode(id){
  if(!nodes[id]) return;
  delete nodes[id];
  delete edges[id];
  for(const u in edges) edges[u] = edges[u].filter(e=> e.v !== id);
  updateSelectors(); drawGraph();
}
function addEdge(u,v,w){
  if(!(u in edges)) edges[u] = [];
  if(!(v in edges)) edges[v] = [];
  if(!edges[u].some(e=>e.v===v)) edges[u].push({v,w});
  if(!edges[v].some(e=>e.v===u)) edges[v].push({v,w});
  drawGraph();
}
function findNodeAt(x,y){
  for(const id in nodes){
    const [nx,ny] = nodes[id];
    if(Math.hypot(nx-x, ny-y) <= NODE_RADIUS) return id;
  }
  return null;
}
function updateSelectors(){
  startSel.innerHTML = ''; endSel.innerHTML = '';
  const keys = Object.keys(nodes).sort();
  for(const k of keys){
    const o1 = document.createElement('option'); o1.value = k; o1.textContent = k; startSel.appendChild(o1);
    const o2 = document.createElement('option'); o2.value = k; o2.textContent = k; endSel.appendChild(o2);
  }
  if(keys.length){
    startSel.value = keys[0];
    endSel.value = keys[keys.length-1];
  }
}
function log(msg){ explainBox.innerHTML += '• ' + msg + '<br>'; explainBox.scrollTop = explainBox.scrollHeight; }
function clearLog(){ explainBox.innerHTML = ''; }
function sleep(ms){ return new Promise(res=>setTimeout(res, ms)); }

// ---------- Dijkstra + path enumeration ----------
function computeDijkstra(start, end){
  const dist = {}, prev = {};
  for(const n in nodes){ dist[n] = Infinity; prev[n] = null; }
  dist[start] = 0;
  const heap = [[0, start]];
  while(heap.length){
    heap.sort((a,b)=>a[0]-b[0]);
    const [d,u] = heap.shift();
    if(d > dist[u]) continue;
    if(u === end) break;
    for(const e of edges[u]||[]){
      const v = e.v, w = e.w;
      if(dist[u] + w < dist[v]){ dist[v] = dist[u] + w; prev[v] = u; heap.push([dist[v], v]); }
    }
  }
  return {dist, prev};
}

function enumerateAllSimplePaths(start, end){
  const results = []; const visited = new Set(); const path = [];
  function dfs(u){
    if(results.length >= MAX_PATHS) return;
    visited.add(u); path.push(u);
    if(u === end){
      let total = 0; let ok = true;
      for(let i=0;i+1<path.length;i++){
        const a = path[i], b = path[i+1];
        const e = edges[a].find(x=>x.v===b);
        if(!e){ ok = false; break; }
        total += e.w;
      }
      if(ok) results.push({nodes: [...path], weight: total});
    } else {
      for(const e of edges[u] || []){
        if(!visited.has(e.v)) dfs(e.v);
        if(results.length >= MAX_PATHS) break;
      }
    }
    path.pop(); visited.delete(u);
  }
  dfs(start);
  return results;
}
function pickLMS(paths){
  if(!paths.length) return {long:null, mid:null, short:null};
  const arr = paths.slice().sort((a,b)=>b.weight - a.weight);
  const longest = arr[0];
  const shortest = arr[arr.length-1];
  const mid = arr[Math.floor(arr.length/2)] || arr[0];
  return {long:longest, mid:mid, short:shortest};
}
function drawPathHighlights(nodeList, color){
  const h = {node:{}, edge:{}};
  for(const n of nodeList) h.node[n] = color;
  for(let i=0;i+1<nodeList.length;i++){
    const a=nodeList[i], b=nodeList[i+1];
    h.edge[`${a}-${b}`] = color; h.edge[`${b}-${a}`] = color;
  }
  drawGraph(h);
}

// animate Long -> Mid -> Short
async function animatePathSequence(picks){
  const delay = Math.max(300, parseInt(speedRange.value) || 900);
  drawGraph(); await sleep(300);
  if(picks.long){ log(`Showing Longest (weight=${picks.long.weight})`); drawPathHighlights(picks.long.nodes, 'var(--neon-red)'); await sleep(delay+200); }
  if(picks.mid){ log(`Showing Medium (weight=${picks.mid.weight})`); drawPathHighlights(picks.mid.nodes, 'var(--neon-orange)'); await sleep(delay+200); }
  if(picks.short){ log(`Showing Shortest (weight=${picks.short.weight})`); drawPathHighlights(picks.short.nodes, 'lime'); await sleep(delay+200); }
  log('Sequence complete. Shortest remains highlighted.');
}

// ---------- Kruskal generator ----------
function* kruskalGenerator(){
  const all = [];
  for(const u in edges){
    for(const e of edges[u]){
      if(u < e.v) all.push({u, v: e.v, w: e.w});
    }
  }
  all.sort((a,b)=>a.w-b.w);
  const parent = {}, rank = {};
  for(const n in nodes){ parent[n] = n; rank[n] = 0; }
  function find(x){ return parent[x] === x ? x : (parent[x] = find(parent[x])); }
  function unite(a,b){
    a = find(a); b = find(b); if(a === b) return false;
    if(rank[a] < rank[b]) [a,b] = [b,a];
    parent[b] = a; if(rank[a] === rank[b]) rank[a]++; return true;
  }
  for(const e of all){
    yield {type:'consider', edge:e};
    if(unite(e.u, e.v)) yield {type:'accept', edge:e};
    else yield {type:'reject', edge:e};
  }
  yield {type:'done'};
}

// ---------- flow controls ----------
async function setupRun(){
  clearLog();
  const algo = algoSel.value;
  if(algo === 'dijkstra'){
    const start = startSel.value, end = endSel.value;
    if(!start || !end){ log('Select Start and End nodes'); return; }
    log(`Dijkstra: enumerating paths ${start} -> ${end} (cap ${MAX_PATHS})`);
    const paths = enumerateAllSimplePaths(start, end);
    if(!paths.length){ log('No path found'); return; }
    if(paths.length >= MAX_PATHS) log(`Found >=${MAX_PATHS} paths (capped).`);
    const picks = pickLMS(paths);
    log(`Paths found: ${paths.length}. Long=${picks.long? picks.long.weight:'N/A'} Mid=${picks.mid? picks.mid.weight:'N/A'} Short=${picks.short? picks.short.weight:'N/A'}`);
    await animatePathSequence(picks);
  } else {
    kruskalGen = kruskalGenerator();
    drawGraph();
    log('Kruskal ready — use Step or Play to run MST.');
  }
}

async function stepOnce(){
  const algo = algoSel.value;
  if(algo === 'dijkstra'){ log('Dijkstra runs full sequence on Setup. Use Setup.'); return; }
  if(!kruskalGen) kruskalGen = kruskalGenerator();
  const nxt = kruskalGen.next();
  if(nxt.done){ log('Kruskal finished'); kruskalGen = null; return; }
  const v = nxt.value;
  if(v.type === 'consider'){ log(`Considering ${v.edge.u}-${v.edge.v} (w=${v.edge.w})`); drawGraph({edge:{[`${v.edge.u}-${v.edge.v}`]:'#ffb85c',[`${v.edge.v}-${v.edge.u}`]:'#ffb85c'}}); }
  else if(v.type === 'accept'){ log(`Accepted ${v.edge.u}-${v.edge.v}`); drawGraph({edge:{[`${v.edge.u}-${v.edge.v}`]:'lime',[`${v.edge.v}-${v.edge.u}`]:'lime'}}); }
  else if(v.type === 'reject'){ log(`Rejected ${v.edge.u}-${v.edge.v} (cycle)`); drawGraph({edge:{[`${v.edge.u}-${v.edge.v}`]:'red',[`${v.edge.v}-${v.edge.u}`]:'red'}}); }
}

function togglePlay(){
  if(playInterval){ clearInterval(playInterval); playInterval = null; playBtn.textContent = 'Play'; log('Paused'); }
  else {
    if(algoSel.value === 'dijkstra'){ log('Play is for Kruskal stepping. Use Setup for Dijkstra full visualization.'); return; }
    playBtn.textContent = 'Pause';
    playInterval = setInterval(()=> stepOnce(), Math.max(200, parseInt(speedRange.value)));
    log('Autoplay Kruskal started');
  }
}

// instant highlight shortest
function showFullPath(){
  if(algoSel.value !== 'dijkstra'){ log('Full-shortest is Dijkstra-only'); return; }
  const start = startSel.value, end = endSel.value;
  if(!start || !end){ log('Select start & end'); return; }
  const {dist, prev} = computeDijkstra(start, end);
  if(!isFinite(dist[end])){ log('No path'); return; }
  // reconstruct
  const seq = [];
  let cur = end;
  while(cur){ seq.push(cur); cur = prev[cur]; if(seq.length > 500) break; }
  seq.reverse();
  drawPathHighlights(seq, 'lime');
  log('Shortest path shown.');
}

// reset
function resetGraph(){
  nodes = {}; edges = {}; mode = 'add'; selectedForEdge = null; kruskalGen = null;
  clearLog(); updateSelectors(); drawGraph();
}

// ---------- presets (use addNodeAt/addEdge to keep internal structure consistent) ----------
function loadPreset(which){
  resetGraph();
  const cx = canvas.width/2, cy = canvas.height/2;
  if(which === 'triangle'){
    addNodeAt(cx-120,cy+60,'A'); addNodeAt(cx,cy-90,'B'); addNodeAt(cx+120,cy+60,'C');
    addEdge('A','B',4); addEdge('B','C',2); addEdge('A','C',1);
  } else if(which === 'square'){
    addNodeAt(cx-140,cy-90,'A'); addNodeAt(cx+140,cy-90,'B'); addNodeAt(cx+140,cy+90,'C'); addNodeAt(cx-140,cy+90,'D');
    addEdge('A','B',3); addEdge('B','C',4); addEdge('C','D',2); addEdge('D','A',1);
  } else if(which === 'chain'){
    addNodeAt(cx-280,cy,'A'); addNodeAt(cx-100,cy,'B'); addNodeAt(cx+80,cy,'C'); addNodeAt(cx+260,cy,'D');
    addEdge('A','B',5); addEdge('B','C',3); addEdge('C','D',6);
  } else if(which === 'random'){
    const N = 6 + Math.floor(Math.random()*3); // 6-8 nodes
    const ids = [];
    for(let i=0;i<N;i++){ const label = getNextLabel(); addNodeAt(cx + Math.cos(i * (2*Math.PI/N)) * 170 + (Math.random()-0.5)*30, cy + Math.sin(i*(2*Math.PI/N)) * 120 + (Math.random()-0.5)*30, label); ids.push(label); }
    // randomly connect
    for(let i=0;i<ids.length;i++){
      for(let j=i+1;j<ids.length;j++){
        if(Math.random() < 0.45){ const w = Math.floor(Math.random()*9)+1; addEdge(ids[i], ids[j], w); }
      }
    }
  } else if(which === 'star'){
    const center = getNextLabel(); addNodeAt(canvas.width/2, canvas.height/2, center);
    const leaves = [];
    for(let i=0;i<6;i++){ const label = getNextLabel(); addNodeAt(canvas.width/2 + Math.cos(i*(2*Math.PI/6))*180, canvas.height/2 + Math.sin(i*(2*Math.PI/6))*120, label); leaves.push(label); }
    for(const l of leaves){ addEdge(center, l, Math.floor(Math.random()*8)+1); }
  } else if(which === 'complete'){
    const N = 6;
    const ids = [];
    for(let i=0;i<N;i++){ const label = getNextLabel(); addNodeAt(canvas.width/2 + Math.cos(i*2*Math.PI/N)*160, canvas.height/2 + Math.sin(i*2*Math.PI/N)*120, label); ids.push(label); }
    for(let i=0;i<ids.length;i++){ for(let j=i+1;j<ids.length;j++){ addEdge(ids[i], ids[j], Math.floor(Math.random()*9)+1); } }
  } else if(which === 'hexagon'){
    const ids = [];
    for(let i=0;i<6;i++){ const label = getNextLabel(); addNodeAt(canvas.width/2 + Math.cos(i*(2*Math.PI/6))*170, canvas.height/2 + Math.sin(i*(2*Math.PI/6))*120, label); ids.push(label); }
    for(let i=0;i<ids.length;i++){ addEdge(ids[i], ids[(i+1)%ids.length], Math.floor(Math.random()*9)+1); }
  }
  updateSelectors(); drawGraph();
  log(`Loaded preset: ${which}`);
}

// initial load
loadPreset('triangle');

</script>
</body>
</html>







