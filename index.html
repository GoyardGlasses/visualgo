

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dijkstra Visualizer (Complete & Fixed)</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    table, th, td { border: 1px solid black; border-collapse: collapse; padding: 6px; }
    #explainBox { border: 1px solid black; padding: 10px; margin-top: 10px; min-height: 80px; background: #f9f9f9; }
    canvas { border: 1px solid black; margin-top: 10px; }
  </style>
</head>
<body>
  <h2>Dijkstraâ€™s Algorithm Visualizer</h2>

  <!-- Input Section -->
  <h3>Graph Input</h3>
  <label>Number of Vertices:</label>
  <input type="number" id="numVertices" min="2" value="4"><br><br>

  <label>Number of Edges:</label>
  <input type="number" id="numEdges" min="1" value="5"><br><br>

  <button onclick="makeEdgeInputs()">Generate Edge Inputs</button>
  <div id="edgeInputs"></div>
  <button onclick="buildGraph()">Build Graph</button>

  <!-- Adjacency Matrix -->
  <h3>Adjacency Matrix</h3>
  <div id="matrix"></div>

  <!-- Distance Table -->
  <h3>Distance Table</h3>
  <table id="distTable">
    <thead>
      <tr><th>Step</th><th>Chosen Node</th><th>Distances (d[])</th><th>Parents (Ï€[])</th></tr>
    </thead>
    <tbody></tbody>
  </table>

  <!-- Explanation -->
  <h3>Step Explanation & Final Paths</h3>
  <div id="explainBox">Build a graph and click "Step".</div>

  <!-- Graph Visualization -->
  <h3>Graph Visualization</h3>
  <canvas id="canvas" width="600" height="400"></canvas>

  <!-- Controls -->
  <button onclick="resetDijkstra()">Reset</button>
  <button onclick="runStep()">Step</button>

  <script>
    let V = 0, E = 0;
    let adjMatrix = [];
    let dist = [], parent = [], visited = [];
    let pq = [];
    let step = 0;
    let edges = [];
    let canvas = document.getElementById("canvas");
    let ctx = canvas.getContext("2d");

    // Generate edge input fields
    function makeEdgeInputs() {
      V = parseInt(document.getElementById("numVertices").value);
      E = parseInt(document.getElementById("numEdges").value);
      let html = "<h4>Enter Edges (u v w)</h4><p>(Use A,B,C... for vertices)</p>";
      for (let i = 0; i < E; i++) {
        html += "Edge " + (i+1) + ": " +
          "<input size='1' id='u"+i+"' placeholder='u'>" +
          "<input size='1' id='v"+i+"' placeholder='v'>" +
          "<input size='2' id='w"+i+"' placeholder='w'><br>";
      }
      document.getElementById("edgeInputs").innerHTML = html;
    }

    // Build adjacency matrix safely
    function buildGraph() {
      if (V === 0 || E === 0) {
        alert("Please enter number of vertices and edges first.");
        return;
      }
      adjMatrix = Array.from({length:V},()=>Array(V).fill("âˆž"));
      edges = [];
      for (let i=0; i<V; i++) adjMatrix[i][i]=0;

      for (let i=0; i<E; i++) {
        let uBox = document.getElementById("u"+i).value.trim().toUpperCase();
        let vBox = document.getElementById("v"+i).value.trim().toUpperCase();
        let wBox = document.getElementById("w"+i).value.trim();

        if (!uBox || !vBox || !wBox) {
          alert("Fill all edge fields before building graph.");
          return;
        }

        let u = uBox.charCodeAt(0)-65;
        let v = vBox.charCodeAt(0)-65;
        let w = parseInt(wBox);

        if (u<0 || u>=V || v<0 || v>=V) {
          alert("Invalid vertex name. Use A,B,C,... within number of vertices.");
          return;
        }

        adjMatrix[u][v]=w;
        adjMatrix[v][u]=w; // undirected
        edges.push({u,v,w,color:"black"});
      }

      updateMatrix();
      resetDijkstra();
      drawGraph();
    }

    // Show adjacency matrix
    function updateMatrix() {
      let html="<table><tr><th></th>";
      for (let i=0; i<V; i++) html+="<th>"+String.fromCharCode(65+i)+"</th>";
      html+="</tr>";
      for (let i=0; i<V; i++) {
        html+="<tr><th>"+String.fromCharCode(65+i)+"</th>";
        for (let j=0; j<V; j++) html+="<td>"+adjMatrix[i][j]+"</td>";
        html+="</tr>";
      }
      html+="</table>";
      document.getElementById("matrix").innerHTML=html;
    }

    // Reset Dijkstra
    function resetDijkstra() {
      dist=Array(V).fill(Infinity);
      parent=Array(V).fill("-");
      visited=Array(V).fill(false);
      dist[0]=0; // source = A
      pq=[0];
      step=0;
      document.querySelector("#distTable tbody").innerHTML="";
      document.getElementById("explainBox").innerHTML="Graph ready. Press Step.";
      edges.forEach(e=>e.color="black");
      drawGraph();
    }

    // Run one step
    function runStep() {
      if (pq.length==0) { 
        document.getElementById("explainBox").innerHTML=
          "âœ… Algorithm finished.<br>" +
          "All shortest paths from source A are now finalized. " +
          "Green edges in the graph show the shortest path tree.";
        highlightFinalTree();
        showFinalPaths();
        return;
      }
      let u = pq.reduce((a,b)=>dist[a]<dist[b]?a:b);
      pq = pq.filter(x=>x!=u);
      if (visited[u]) return runStep();
      visited[u]=true;

      let exp = "<b>Step "+(++step)+":</b> We now pick <b>node "+
                String.fromCharCode(65+u)+"</b> " +
                "because it currently has the smallest known distance ("+dist[u]+").<br><br>";

      for (let v=0; v<V; v++) {
        if (adjMatrix[u][v]!="âˆž" && !visited[v]) {
          let candidate = dist[u]+parseInt(adjMatrix[u][v]);
          if (candidate < dist[v]) {
            exp += "âœ” Looking at edge <b>"+String.fromCharCode(65+u)+" â†’ "+String.fromCharCode(65+v)+"</b> (weight "+adjMatrix[u][v]+").<br>" +
                   "New possible distance = "+dist[u]+" + "+adjMatrix[u][v]+" = "+candidate+".<br>" +
                   "This is smaller than current distance to "+String.fromCharCode(65+v)+" ("+dist[v]+").<br>" +
                   "ðŸ‘‰ Update distance of "+String.fromCharCode(65+v)+" to "+candidate+
                   " and set parent = "+String.fromCharCode(65+u)+".<br><br>";
            dist[v]=candidate;
            parent[v]=String.fromCharCode(65+u);
            pq.push(v);
            colorEdge(u,v,"green");
          } else if (candidate === dist[v]) {
            exp += "âš– Edge <b>"+String.fromCharCode(65+u)+" â†’ "+String.fromCharCode(65+v)+"</b> (weight "+adjMatrix[u][v]+").<br>" +
                   "New possible distance = "+candidate+
                   ", equal to current distance for "+String.fromCharCode(65+v)+".<br>" +
                   "ðŸ‘‰ Both paths are equally good. Keeping the current parent for stability.<br><br>";
            colorEdge(u,v,"orange");
          } else {
            exp += "âœ˜ Edge <b>"+String.fromCharCode(65+u)+" â†’ "+String.fromCharCode(65+v)+"</b> (weight "+adjMatrix[u][v]+").<br>" +
                   "New possible distance = "+candidate+
                   ", greater than current distance ("+dist[v]+").<br>" +
                   "ðŸ‘‰ Reject this path, keep existing shorter path.<br><br>";
            colorEdge(u,v,"red");
          }
        }
      }

      let row="<tr><td>"+step+"</td><td>"+String.fromCharCode(65+u)+"</td><td>"+dist.map(d=>d==Infinity?\"âˆž\":d).join(\", \")+"</td><td>"+parent.join(\", \")+"</td></tr>";
      document.querySelector("#distTable tbody").innerHTML+=row;

      document.getElementById("explainBox").innerHTML=exp;
      drawGraph();
    }

    // Color an edge
    function colorEdge(u,v,color) {
      edges.forEach(e=>{
        if ((e.u===u && e.v===v)||(e.u===v && e.v===u)) e.color=color;
      });
    }

    // Highlight final shortest path tree
    function highlightFinalTree() {
      for (let v=1; v<V; v++) {
        if (parent[v]!=="-") {
          let u = parent[v].charCodeAt(0)-65;
          colorEdge(u,v,"green");
        }
      }
      drawGraph();
    }

    // Reconstruct final shortest paths
    function showFinalPaths() {
      let output = "<br><b>Final Shortest Paths from Source A:</b><br><br>";
      for (let v = 1; v < V; v++) {
        if (dist[v] === Infinity) {
          output += "No path to " + String.fromCharCode(65+v) + "<br>";
        } else {
          let path = [];
          let current = v;
          while (current !== 0 && parent[current] !== "-") {
            path.push(String.fromCharCode(65+current));
            current = parent[current].charCodeAt(0) - 65;
          }
          path.push("A");
          path.reverse();
          output += "Path to " + String.fromCharCode(65+v) + ": " +
                    path.join(" â†’ ") + 
                    " (Cost = " + dist[v] + ")<br>";
        }
      }
      document.getElementById("explainBox").innerHTML += output;
    }

    // Draw graph
    function drawGraph() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      let R=150, cx=300, cy=200;
      let positions=[];
      for (let i=0;i<V;i++) {
        let angle=2*Math.PI*i/V;
        positions.push({x:cx+R*Math.cos(angle), y:cy+R*Math.sin(angle)});
      }
      // draw edges
      edges.forEach(e=>{
        let u=positions[e.u], v=positions[e.v];
        ctx.beginPath();
        ctx.strokeStyle=e.color;
        ctx.moveTo(u.x,u.y);
        ctx.lineTo(v.x,v.y);
        ctx.stroke();
        ctx.fillStyle="black";
        ctx.fillText(e.w,(u.x+v.x)/2,(u.y+v.y)/2);
      });
      // draw nodes
      for (let i=0;i<V;i++) {
        ctx.beginPath();
        ctx.arc(positions[i].x,positions[i].y,20,0,2*Math.PI);
        ctx.fillStyle="lightblue";
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle="black";
        ctx.fillText(String.fromCharCode(65+i),positions[i].x-5,positions[i].y+5);
      }
    }
  </script>
</body>
</html>










