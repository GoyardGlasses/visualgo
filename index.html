<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cyberpunk Graph Visualizer</title>
  <style>
    body { display: flex; margin: 0; font-family: 'Orbitron', sans-serif; height: 100vh; background: #0a0a0f; color: #0ff; }
    #sidebar { width: 360px; background: #111122; color: #0ff; padding: 15px; display: flex; flex-direction: column; box-shadow: 0 0 20px #0ff; }
    #canvas { flex: 1; background: #050510; cursor: crosshair; }

    h2 { margin: 5px 0; color: #f0f; text-shadow: 0 0 10px #f0f; }

    button, select, input[type=range] {
      margin: 6px 0; padding: 8px; border: 1px solid #0ff; border-radius: 6px;
      background: #111; color: #0ff; cursor: pointer; font-family: 'Orbitron', sans-serif;
      transition: 0.2s;
    }
    button:hover, select:hover {
      background: #0ff; color: #111; box-shadow: 0 0 10px #0ff;
    }
    input[type=range] { accent-color: #f0f; }

    #explanation {
      flex: 1; overflow-y: auto; background: #000; padding: 8px;
      border: 1px solid #f0f; border-radius: 6px; margin-top: 10px;
      font-size: 12px; color: #0f0; font-family: monospace;
    }

    label { margin-top: 5px; font-size: 14px; color: #0ff; }

    #legend {
      background: #111; padding: 6px; border: 1px solid #0ff;
      border-radius: 6px; margin-top: 10px; font-size: 12px; color: #fff;
    }
    .legend-item { margin: 4px 0; }
    .color-box { display: inline-block; width: 16px; height: 16px; margin-right: 6px; vertical-align: middle; }
  </style>
</head>
<body>
  <div id="sidebar">
    <h2>⚡ Cyberpunk Graph Visualizer ⚡</h2>

    <label>Mode:</label>
    <select id="mode">
      <option value="move">Move</option>
      <option value="add">Add Node</option>
      <option value="edge">Add Edge</option>
    </select>

    <label>Algorithm:</label>
    <select id="algorithm">
      <option value="dijkstra">Dijkstra (Shortest Path)</option>
      <option value="kruskal">Kruskal (MST)</option>
    </select>

    <div id="dijkstraOptions">
      <label>Start:</label>
      <select id="startNode"></select>
      <label>End:</label>
      <select id="endNode"></select>
    </div>

    <label>Presets:</label>
    <select id="preset" onchange="loadPreset(this.value)">
      <option value="">-- Select Preset --</option>
      <option value="triangle">Triangle Graph</option>
      <option value="square">Square Graph</option>
      <option value="chain">Weighted Chain</option>
      <option value="random">Random Graph</option>
    </select>

    <button onclick="setupRun()">Setup</button>
    <button onclick="stepOnce()">Step</button>
    <button onclick="togglePlay()" id="playBtn">Play</button>
    <button onclick="showFullPath()">Show Full Path (Dijkstra)</button>
    <label for="speed">Speed:</label>
    <input type="range" id="speed" min="200" max="2000" step="100" value="800">
    <button onclick="resetGraph()">Reset</button>

    <div id="legend">
      <h3>Legend</h3>
      <div class="legend-item"><span class="color-box" style="background: cyan;"></span> Unvisited Node</div>
      <div class="legend-item"><span class="color-box" style="background: orange;"></span> Current Node (Dijkstra)</div>
      <div class="legend-item"><span class="color-box" style="background: lime;"></span> Final Path / Accepted Edge</div>
      <div class="legend-item"><span class="color-box" style="background: red;"></span> Rejected Edge (Kruskal)</div>
      <div class="legend-item"><span class="color-box" style="background: #888;"></span> Normal Edge</div>
    </div>

    <div id="explanation"></div>
  </div>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth - 360;
    canvas.height = window.innerHeight;

    const NODE_RADIUS = 20;
    let nodes = {};
    let edges = {};
    let nodeCount = 0;
    let selectedNode = null;

    let generator = null;
    let playing = false;
    let lastPrev = null;

    function drawGraph(highlights = {}) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.lineWidth = 2;
      // Draw edges
      for (let u in edges) {
        for (let { v, w } of edges[u]) {
          const [x1, y1] = nodes[u];
          const [x2, y2] = nodes[v];
          ctx.strokeStyle = (highlights.edge && highlights.edge[`${u}-${v}`]) || "#888";
          ctx.shadowBlur = 10; ctx.shadowColor = ctx.strokeStyle;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          ctx.shadowBlur = 0;
          ctx.fillStyle = "yellow";
          ctx.fillText(w, (x1+x2)/2, (y1+y2)/2);
        }
      }
      // Draw nodes
      for (let n in nodes) {
        const [x, y] = nodes[n];
        ctx.fillStyle = (highlights.node && highlights.node[n]) || "cyan";
        ctx.beginPath();
        ctx.arc(x, y, NODE_RADIUS, 0, 2*Math.PI);
        ctx.fill();
        ctx.strokeStyle = "white";
        ctx.stroke();
        ctx.fillStyle = "black";
        ctx.fillText(n, x-4, y+4);
      }
    }

    canvas.addEventListener("click", e => {
      const mode = document.getElementById("mode").value;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (mode === "add") {
        const name = String.fromCharCode(65 + nodeCount++);
        nodes[name] = [x, y];
        edges[name] = [];
        updateSelectors();
      } else if (mode === "edge") {
        const node = findNode(x, y);
        if (node) {
          if (!selectedNode) {
            selectedNode = node;
          } else {
            const w = parseInt(prompt("Enter weight:"));
            if (!isNaN(w)) {
              edges[selectedNode].push({ v: node, w });
              edges[node].push({ v: selectedNode, w });
            }
            selectedNode = null;
          }
        }
      }
      drawGraph();
    });

    function findNode(x, y) {
      for (let n in nodes) {
        const [nx, ny] = nodes[n];
        if (Math.hypot(nx - x, ny - y) <= NODE_RADIUS) return n;
      }
      return null;
    }

    function updateSelectors() {
      const startSel = document.getElementById("startNode");
      const endSel = document.getElementById("endNode");
      startSel.innerHTML = endSel.innerHTML = "";
      for (let n in nodes) {
        startSel.add(new Option(n, n));
        endSel.add(new Option(n, n));
      }
    }

    function* dijkstraSteps(start, end) {
      let dist = {}, prev = {}, heap = [];
      for (let n in nodes) { dist[n] = Infinity; prev[n] = null; }
      dist[start] = 0;
      heap.push([0, start]);
      log("Initialized distances.");
      lastPrev = prev;

      while (heap.length) {
        heap.sort((a,b)=>a[0]-b[0]);
        let [d, u] = heap.shift();
        log(`POP: ${u} with dist ${d}`);
        if (u === end) break;
        for (let { v, w } of edges[u]) {
          log(`Consider edge ${u} → ${v} (w=${w})`);
          if (d+w < dist[v]) {
            dist[v] = d+w;
            prev[v] = u;
            heap.push([dist[v], v]);
            log(`Relax: Update ${v} to dist ${dist[v]}`);
          }
        }
        lastPrev = { ...prev };
        yield drawGraph({ node: { [u]: "orange" } });
      }
      log("Dijkstra finished.");
      yield* highlightPath(prev, end);
    }

    function* highlightPath(prev, end) {
      let node = end;
      while (prev[node]) {
        const p = prev[node];
        yield drawGraph({
          node: { [node]: "lime", [p]: "lime" },
          edge: { [`${p}-${node}`]: "lime", [`${node}-${p}`]: "lime" }
        });
        node = p;
      }
    }

    function* kruskalSteps() {
      let allEdges = [];
      for (let u in edges) {
        for (let { v, w } of edges[u]) {
          if (u < v) allEdges.push({ u, v, w });
        }
      }
      allEdges.sort((a,b)=>a.w-b.w);

      let parent = {}, rank = {};
      for (let n in nodes) { parent[n]=n; rank[n]=0; }

      function find(x){ if(parent[x]!==x) parent[x]=find(parent[x]); return parent[x]; }
      function unite(x,y){ x=find(x); y=find(y); if(x!==y){ if(rank[x]<rank[y]) [x,y]=[y,x]; parent[y]=x; if(rank[x]===rank[y]) rank[x]++; return true;} return false; }

      for (let e of allEdges) {
        log(`Considering edge ${e.u}-${e.v} (w=${e.w})`);
        if (unite(e.u, e.v)) {
          log(`Accepted edge ${e.u}-${e.v}`);
          yield drawGraph({ edge: { [`${e.u}-${e.v}`]: "lime", [`${e.v}-${e.u}`]: "lime" } });
        } else {
          log(`Rejected edge ${e.u}-${e.v} (cycle)`);
          yield drawGraph({ edge: { [`${e.u}-${e.v}`]: "red", [`${e.v}-${e.u}`]: "red" } });
        }
      }
      log("Kruskal finished.");
    }

    function setupRun() {
      const algo = document.getElementById("algorithm").value;
      if (algo === "dijkstra") {
        const start = document.getElementById("startNode").value;
        const end = document.getElementById("endNode").value;
        if (!start || !end) return;
        generator = dijkstraSteps(start, end);
      } else {
        generator = kruskalSteps();
      }
      stepOnce();
    }

    function stepOnce() {
      if (!generator) return;
      const res = generator.next();
      if (res.done) { log("Done."); playing = false; return; }
    }

    function togglePlay() {
      playing = !playing;
      document.getElementById("playBtn").innerText = playing ? "Pause" : "Play";
      if (playing) loop();
    }

    function loop() {
      if (!playing) return;
      stepOnce();
      let delay = parseInt(document.getElementById("speed").value);
      setTimeout(loop, delay);
    }

    function showFullPath() {
      const algo = document.getElementById("algorithm").value;
      if (algo !== "dijkstra" || !lastPrev) {
        log("⚠ Only works for Dijkstra after Setup!");
        return;
      }
      const end = document.getElementById("endNode").value;
      drawGraph();
      let node = end;
      while (lastPrev[node]) {
        const p = lastPrev[node];
        drawGraph({
          node: { [node]: "lime", [p]: "lime" },
          edge: { [`${p}-${node}`]: "lime", [`${node}-${p}`]: "lime" }
        });
        node = p;
      }
      log("Full path highlighted instantly.");
    }

    function resetGraph() {
      nodes = {}; edges = {}; nodeCount = 0; selectedNode = null; generator = null;
      lastPrev = null;
      document.getElementById("startNode").innerHTML = "";
      document.getElementById("endNode").innerHTML = "";
      ctx.clearRect(0,0,canvas.width,canvas.height);
      document.getElementById("explanation").innerHTML = "";
    }

    function log(msg) {
      const exp = document.getElementById("explanation");
      exp.innerHTML += msg+"<br>";
      exp.scrollTop = exp.scrollHeight;
    }

    // === PRESETS ===
    function loadPreset(type) {
      resetGraph();
      const cx = canvas.width / 2, cy = canvas.height / 2;
      if (type === "triangle") {
        nodes = { A:[cx-100, cy+50], B:[cx, cy-100], C:[cx+100, cy+50] };
        edges = { A:[{v:"B",w:4},{v:"C",w:1}], B:[{v:"A",w:4},{v:"C",w:2}], C:[{v:"A",w:1},{v:"B",w:2}] };
        nodeCount=3;
      } else if (type === "square") {
        nodes = { A:[cx-100, cy-100], B:[cx+100, cy-100], C:[cx+100, cy+100], D:[cx-100, cy+100] };
        edges = {
          A:[{v:"B",w:3},{v:"D",w:1}],
          B:[{v:"A",w:3},{v:"C",w:4}],
          C:[{v:"B",w:4},{v:"D",w:2}],
          D:[{v:"A",w:1},{v:"C",w:2}]
        };
        nodeCount=4;
      } else if (type === "chain") {
        nodes = { A:[cx-200, cy], B:[cx-50, cy], C:[cx+100, cy], D:[cx+250, cy] };
        edges = {
          A:[{v:"B",w:5}],
          B:[{v:"A",w:5},{v:"C",w:3}],
          C:[{v:"B",w:3},{v:"D",w:6}],
          D:[{v:"C",w:6}]
        };
        nodeCount=4;
      } else if (type === "random") {
        nodes={}; edges={}; nodeCount=0;
        for(let i=0;i<5;i++){
          const name=String.fromCharCode(65+nodeCount++);
          nodes[name]=[cx+Math.cos(i*1.25)*150, cy+Math.sin(i*1.25)*150];
          edges[name]=[];
        }
        const nodeNames=Object.keys(nodes);
        for(let i=0;i<nodeNames.length;i++){
          for(let j=i+1;j<nodeNames.length;j++){
            if(Math.random()<0.4){
              const w=Math.floor(Math.random()*9)+1;
              edges[nodeNames[i]].push({v:nodeNames[j],w});
              edges[nodeNames[j]].push({v:nodeNames[i],w});
            }
          }
        }
      }
      updateSelectors();
      drawGraph();
    }

    drawGraph();
  </script>
</body>
</html>




