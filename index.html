<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cyberpunk Graph Visualizer — Dijkstra & Kruskal</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#05030a; --panel:#0b0b17; --neon-cyan:#00ffe1; --neon-pink:#ff4df0; --neon-green:#7bff6b; --neon-orange:#ffb85c; --neon-red:#ff5370;
    --muted:#9aa7b2;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#030312 0%,#060316 100%);font-family:Orbitron,system-ui,Arial;color:var(--neon-cyan);}
  .app{display:grid;grid-template-columns:380px 1fr;gap:18px;padding:18px;height:100vh;box-sizing:border-box}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03)}
  .sidebar{display:flex;flex-direction:column;gap:10px}
  label{font-size:13px;color:var(--muted)}
  select, button, input[type=range]{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px;border-radius:8px;color:var(--neon-cyan);outline:none}
  button { cursor:pointer }
  button:hover{ box-shadow:0 0 12px rgba(0,255,225,0.06); transform:translateY(-2px) }
  #legend{font-size:13px;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;color:var(--muted)}
  .legend-item{display:flex;align-items:center;gap:8px;margin:6px 0}
  .color-box{width:18px;height:14px;border-radius:4px;border:1px solid rgba(255,255,255,0.05)}
  #explain{height:240px;overflow:auto;background:rgba(0,0,0,0.25);padding:8px;border-radius:8px;font-family:monospace;color:#bdebbd}
  #canvasWrap{border-radius:12px;overflow:hidden;position:relative;background:linear-gradient(180deg,#020214,#050117)}
  canvas{display:block;width:100%;height:100%}
  .controls-row{display:flex;gap:8px;align-items:center}
  .small{font-size:12px;color:var(--muted)}
  footer{font-size:12px;color:var(--muted);margin-top:6px}
  @media (max-width:1000px){ .app{grid-template-columns:1fr;grid-auto-rows:auto} }
</style>
</head>
<body>
<div class="app">
  <div class="panel sidebar">
    <h2 style="margin:0 0 6px 0;color:var(--neon-pink)">⚡ Cyberpunk Graph Visualizer</h2>

    <div>
      <label>Mode</label><br/>
      <select id="mode"><option value="move">Move</option><option value="add">Add Node</option><option value="edge">Add Edge</option><option value="delete">Delete Node</option></select>
    </div>

    <div>
      <label>Algorithm</label><br/>
      <select id="algorithm"><option value="dijkstra">Dijkstra (shortest)</option><option value="kruskal">Kruskal (MST)</option></select>
    </div>

    <div id="dijkstraOptions">
      <label>Start</label><br/><select id="startNode"></select>
      <label>End</label><br/><select id="endNode"></select>
    </div>

    <div>
      <label>Presets</label><br/>
      <select id="preset"><option value="">-- choose preset --</option>
        <option value="triangle">Triangle</option>
        <option value="square">Square</option>
        <option value="chain">Weighted Chain</option>
        <option value="random">Random</option>
        <option value="star">Star</option>
        <option value="complete">Complete (n=6)</option>
        <option value="hexagon">Hexagon</option>
      </select>
      <div style="margin-top:8px" class="controls-row">
        <button id="loadPresetBtn">Load</button>
        <button id="clearBtn">Clear</button>
      </div>
    </div>

    <div class="controls-row">
      <button id="setupBtn">Setup</button>
      <button id="stepBtn">Step</button>
      <button id="playBtn">Play</button>
    </div>

    <div style="margin-top:4px">
      <label>Speed (ms)</label><br/>
      <input id="speed" type="range" min="200" max="2000" step="100" value="900">
      <div class="small">Current: <span id="speedVal">900</span> ms</div>
    </div>

    <div style="margin-top:6px">
      <button id="showFullBtn">Show Full Shortest (instant)</button>
    </div>

    <div id="legend" style="margin-top:10px">
      <strong style="color:var(--neon-pink)">Legend</strong>
      <div class="legend-item"><span class="color-box" style="background:cyan"></span> Unvisited Node</div>
      <div class="legend-item"><span class="color-box" style="background:var(--neon-orange)"></span> Medium Path (Dijkstra)</div>
      <div class="legend-item"><span class="color-box" style="background:var(--neon-red)"></span> Longest Path (Dijkstra)</div>
      <div class="legend-item"><span class="color-box" style="background:var(--neon-green)"></span> Shortest Path or Accepted Edge</div>
      <div class="legend-item"><span class="color-box" style="background:#888"></span> Normal Edge</div>
    </div>

    <div style="margin-top:10px">
      <div style="font-size:13px;color:var(--muted)">Explanation / Log</div>
      <div id="explain"></div>
    </div>

    <footer>Built for demo — show Long → Mid → Short automatically for Dijkstra</footer>
  </div>

  <div id="canvasWrap" class="panel">
    <canvas id="c"></canvas>
  </div>
</div>

<script>
/* -----------------------------
   Graph Visualizer - JS
   - nodes: {label: [x,y]}
   - edges: {label: [{v:other, w:weight}, ...]}
------------------------------*/
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
function resizeCanvas(){
  canvas.width = document.getElementById('canvasWrap').clientWidth;
  canvas.height = window.innerHeight - 36;
  drawGraph();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const NODE_RADIUS = 22;
let nodes = {};
let edges = {};
let nodeCount = 0;
let mode = 'add';
let selectedForEdge = null;
let dragging = null;
let dragOffset = null;

const MAX_PATHS = 5000; // safety cap for path enumeration

// UI refs
const modeSel = document.getElementById('mode');
const algoSel = document.getElementById('algorithm');
const startSel = document.getElementById('startNode');
const endSel = document.getElementById('endNode');
const presetSel = document.getElementById('preset');
const loadPresetBtn = document.getElementById('loadPresetBtn');
const clearBtn = document.getElementById('clearBtn');
const setupBtn = document.getElementById('setupBtn');
const stepBtn = document.getElementById('stepBtn');
const playBtn = document.getElementById('playBtn');
const showFullBtn = document.getElementById('showFullBtn');
const explainBox = document.getElementById('explain');
const speedRange = document.getElementById('speed');
const speedVal = document.getElementById('speedVal');

speedRange.addEventListener('input', ()=> speedVal.innerText = speedRange.value);
modeSel.addEventListener('change', ()=> mode = modeSel.value);

loadPresetBtn.addEventListener('click', ()=> loadPreset(presetSel.value));
clearBtn.addEventListener('click', resetGraph);
setupBtn.addEventListener('click', setupRun);
stepBtn.addEventListener('click', stepOnce);
playBtn.addEventListener('click', togglePlay);
showFullBtn.addEventListener('click', showFullPath);

canvas.addEventListener('click', onCanvasClick);
canvas.addEventListener('mousedown', onMouseDown);
canvas.addEventListener('mousemove', onMouseMove);
window.addEventListener('mouseup', onMouseUp);

// drawing / highlights support
function drawGraph(highlights = {node:{}, edge:{}}){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.lineWidth = 3;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = '14px monospace';

  // edges (drawn first)
  for(const u in edges){
    for(const e of edges[u]){
      const v = e.v;
      // to avoid duplicate labeling, we will draw both directions but it's okay; highlights key uses `${u}-${v}`
      const key = `${u}-${v}`;
      const col = highlights.edge && highlights.edge[key] ? highlights.edge[key] : '#888';
      ctx.strokeStyle = col;
      ctx.shadowBlur = col==='lime' || col==='var(--neon-green)' ? 12 : (col==='red'?6:0);
      ctx.beginPath();
      const [x1,y1] = nodes[u];
      const [x2,y2] = nodes[v];
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
      ctx.shadowBlur = 0;
      // weight
      ctx.fillStyle = '#ffd66b';
      ctx.fillText(e.w, (x1+x2)/2, (y1+y2)/2 - 12);
    }
  }

  // nodes
  for(const id in nodes){
    const [x,y] = nodes[id];
    const fill = highlights.node && highlights.node[id] ? highlights.node[id] : 'cyan';
    ctx.beginPath();
    ctx.fillStyle = fill;
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.arc(x,y,NODE_RADIUS,0,Math.PI*2);
    ctx.fill();
    ctx.stroke();
    // label
    ctx.fillStyle = '#071322';
    ctx.font = 'bold 14px monospace';
    ctx.fillText(id, x, y);
  }
}

// utilities
function uid(){ return String.fromCharCode(65 + nodeCount); }
function addNodeAt(x,y,label=null){
  const id = label || uid();
  if(!label) nodeCount++;
  nodes[id] = [x,y];
  edges[id] = edges[id] || [];
  updateSelectors();
  drawGraph();
}
function removeNode(id){
  if(!nodes[id]) return;
  // remove edges referencing id
  delete nodes[id];
  delete edges[id];
  for(const u in edges){
    edges[u] = edges[u].filter(e=> e.v !== id);
  }
  updateSelectors();
  drawGraph();
}
function addEdge(u,v,w){
  if(!edges[u]) edges[u]=[];
  if(!edges[v]) edges[v]=[];
  // avoid duplicates: if edge exists from u->v with same weight, keep; still allow parallel? we skip duplicates
  if(!edges[u].some(e=>e.v===v)){
    edges[u].push({v,w});
  }
  if(!edges[v].some(e=>e.v===u)){
    edges[v].push({v,w});
  }
  drawGraph();
}
function findNodeAt(x,y){
  for(const id in nodes){
    const [nx,ny] = nodes[id];
    if(Math.hypot(nx-x,ny-y) <= NODE_RADIUS) return id;
  }
  return null;
}
function updateSelectors(){
  startSel.innerHTML = ''; endSel.innerHTML = '';
  const keys = Object.keys(nodes).sort();
  for(const k of keys){
    const o1 = document.createElement('option'); o1.value=k; o1.textContent=k; startSel.appendChild(o1);
    const o2 = document.createElement('option'); o2.value=k; o2.textContent=k; endSel.appendChild(o2);
  }
}

// canvas interactions
function onCanvasClick(ev){
  const rect = canvas.getBoundingClientRect();
  const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
  if(mode === 'add'){
    const label = uid();
    addNodeAt(x,y,label);
  } else if(mode === 'edge'){
    const node = findNodeAt(x,y);
    if(!node) return;
    if(!selectedForEdge){ selectedForEdge = node; flashNode(node,'#ffb85c'); log(`Selected ${node} as endpoint 1`); }
    else if(selectedForEdge === node){ log('Cannot connect node to itself'); selectedForEdge = null; drawGraph(); }
    else {
      const w = prompt(`Weight for edge ${selectedForEdge} ↔ ${node}`, '1');
      const ww = Math.max(1, Number(w) || 1);
      addEdge(selectedForEdge, node, ww);
      log(`Added edge ${selectedForEdge} ↔ ${node} (w=${ww})`);
      selectedForEdge = null;
    }
  } else if(mode === 'delete'){
    const node = findNodeAt(x,y); if(node){ removeNode(node); log(`Deleted node ${node}`); }
  }
}

function onMouseDown(ev){
  if(mode !== 'move') return;
  const rect = canvas.getBoundingClientRect();
  const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
  const node = findNodeAt(x,y);
  if(node){ dragging = node; dragOffset = [x - nodes[node][0], y - nodes[node][1]]; }
}
function onMouseMove(ev){
  if(!dragging) return;
  const rect = canvas.getBoundingClientRect();
  const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
  nodes[dragging][0] = x - dragOffset[0];
  nodes[dragging][1] = y - dragOffset[1];
  drawGraph();
}
function onMouseUp(ev){
  dragging = null; dragOffset = null;
}

// logging & visual helpers
function log(s){ explainBox.innerHTML += '• ' + s + '<br>'; explainBox.scrollTop = explainBox.scrollHeight; }
function flashNode(id, color='orange', ms=600){
  const before = {};
  before[id] = 'cyan';
  drawGraph({node:{ [id]: color }});
  setTimeout(()=> drawGraph(), ms);
}

/* ======================
   Dijkstra: compute dist + prev, then enumerate all simple paths
   and animate Longest (red) -> Medium (orange) -> Shortest (green)
   Works for any graph but caps path enumeration to MAX_PATHS for safety.
   ====================== */

function computeDijkstra(start, end){
  // standard Dijkstra to get distances and prev (for one shortest path)
  const dist = {}; const prev = {}; const visited = new Set();
  for(const n in nodes){ dist[n]=Infinity; prev[n]=null; }
  dist[start]=0;
  const heap = [[0,start]];
  while(heap.length){
    heap.sort((a,b)=>a[0]-b[0]);
    const [d,u] = heap.shift();
    if(d>dist[u]) continue;
    if(u===end) break;
    for(const e of edges[u] || []){
      const v = e.v, w = e.w;
      if(dist[u] + w < dist[v]){
        dist[v] = dist[u] + w;
        prev[v] = u;
        heap.push([dist[v], v]);
      }
    }
  }
  return {dist, prev};
}

// enumerate all simple paths using DFS (backtracking). Cap at MAX_PATHS.
function enumerateAllSimplePaths(start, end){
  const results = [];
  const visited = new Set();
  const path = [];
  function dfs(u){
    if(results.length >= MAX_PATHS) return;
    visited.add(u); path.push(u);
    if(u === end){
      // compute weight sum
      let total = 0;
      for(let i=0;i+1<path.length;i++){
        const a = path[i], b = path[i+1];
        const e = edges[a].find(x=>x.v===b);
        total += e ? e.w : Infinity;
      }
      results.push({nodes: [...path], weight: total});
    } else {
      for(const e of edges[u] || []){
        const v = e.v;
        if(!visited.has(v)) dfs(v);
        if(results.length >= MAX_PATHS) break;
      }
    }
    path.pop(); visited.delete(u);
  }
  dfs(start);
  return results;
}

// given list of paths with weights, choose longest, median, shortest
function pickLMS(paths){
  if(!paths.length) return {long:null, mid:null, short:null};
  const arr = paths.slice().filter(p=>isFinite(p.weight));
  arr.sort((a,b)=>b.weight - a.weight); // descending
  const longest = arr[0];
  const shortest = arr[arr.length-1];
  const mid = arr[Math.floor(arr.length/2)] || null;
  return {long:longest, mid:mid, short:shortest};
}

async function animatePathSequence(pathsObj){
  // Show Long (red) -> Mid (orange) -> Short (green)
  const delay = parseInt(speedRange.value) || 800;
  drawGraph(); await sleep(300);
  if(pathsObj.long){
    await highlightOnePath(pathsObj.long.nodes, 'red', delay);
  }
  if(pathsObj.mid){
    await highlightOnePath(pathsObj.mid.nodes, 'orange', delay);
  }
  if(pathsObj.short){
    await highlightOnePath(pathsObj.short.nodes, 'lime', delay);
  }
  log('Finished showing Long → Mid → Short. Shortest remains highlighted.');
}

function drawPathHighlights(nodeList, color){
  const h = { node: {}, edge: {} };
  for(const n of nodeList) h.node[n] = color;
  for(let i=0;i+1<nodeList.length;i++){
    const a=nodeList[i], b=nodeList[i+1];
    h.edge[`${a}-${b}`] = color; h.edge[`${b}-${a}`] = color;
  }
  drawGraph(h);
}
function sleep(ms){ return new Promise(res=>setTimeout(res, ms)); }

async function highlightOnePath(nodeList, color, showMs){
  drawPathHighlights(nodeList, color);
  await sleep(showMs + 200);
}

/* ================
   High level flow
   ================*/
let autoPlaying = false;
async function setupRun(){
  clearLog();
  const algo = algoSel.value;
  if(algo === 'dijkstra'){
    const start = startSel.value, end = endSel.value;
    if(!start || !end){ log('Choose Start and End nodes'); return; }
    log(`Running Dijkstra: start=${start}, end=${end}`);
    // compute distances (and shortest prev)
    const {dist, prev} = computeDijkstra(start,end);
    if(!isFinite(dist[end])){ log('No path exists between start and end'); return; }
    // enumerate all simple paths
    log('Enumerating all simple paths (capped) — please wait...');
    const paths = enumerateAllSimplePaths(start, end);
    if(paths.length === 0){ log('No paths found'); return; }
    if(paths.length >= MAX_PATHS){ log(`Path count capped at ${MAX_PATHS}. Results may be partial.`); }
    // compute picks
    const picks = pickLMS(paths);
    log(`Found ${paths.length} path(s). Long=${picks.long ? picks.long.weight : 'N/A'}, Mid=${picks.mid? picks.mid.weight:'N/A'}, Short=${picks.short? picks.short.weight:'N/A'}`);
    await animatePathSequence(picks);
  } else { // kruskal
    log('Setup Kruskal: use Step or Play to walk through MST construction.');
    // create a generator for Kruskal steps (stateful)
    kruskalGen = kruskalGenerator();
    // show initial graph
    drawGraph();
  }
}

let kruskalGen = null;
function* kruskalGenerator(){
  // gather edges unique (u<v)
  const all = [];
  for(const u in edges){
    for(const e of edges[u]){
      if(u < e.v) all.push({u, v: e.v, w: e.w});
    }
  }
  all.sort((a,b)=>a.w-b.w);
  const parent = {}, rank = {};
  for(const n in nodes){ parent[n]=n; rank[n]=0; }
  function find(x){ return parent[x]===x ? x : (parent[x]=find(parent[x])); }
  function unite(a,b){
    a = find(a); b = find(b); if(a===b) return false;
    if(rank[a] < rank[b]) [a,b] = [b,a];
    parent[b]=a; if(rank[a]===rank[b]) rank[a]++; return true;
  }
  for(const e of all){
    yield {type:'consider', edge:e};
    if(unite(e.u, e.v)){
      yield {type:'accept', edge:e};
    } else {
      yield {type:'reject', edge:e};
    }
  }
  yield {type:'done'};
}

async function stepOnce(){
  const algo = algoSel.value;
  if(algo === 'dijkstra'){
    // for Dijkstra we do not step: Setup auto-animates full sequence
    log('Dijkstra runs as a full visualization after Setup (use Step/Play only for Kruskal).');
    return;
  } else {
    if(!kruskalGen){ kruskalGen = kruskalGenerator(); }
    const {value, done} = kruskalGen.next();
    if(done){ log('Kruskal finished'); return; }
    const v = value;
    if(v.type === 'consider'){ log(`Considering edge ${v.edge.u}-${v.edge.v} (w=${v.edge.w})`); drawGraph({edge:{[`${v.edge.u}-${v.edge.v}`]:'#ffb85c',[`${v.edge.v}-${v.edge.u}`]:'#ffb85c'}}); }
    else if(v.type === 'accept'){ log(`Accepted ${v.edge.u}-${v.edge.v}`); drawGraph({edge:{[`${v.edge.u}-${v.edge.v}`]:'lime',[`${v.edge.v}-${v.edge.u}`]:'lime'}}); }
    else if(v.type === 'reject'){ log(`Rejected ${v.edge.u}-${v.edge.v} (cycle)`); drawGraph({edge:{[`${v.edge.u}-${v.edge.v}`]:'red',[`${v.edge.v}-${v.edge.u}`]:'red'}}); }
  }
}

let playTimer = null;
function togglePlay(){
  if(playTimer){ clearInterval(playTimer); playTimer = null; playBtn.textContent='Play'; log('Paused'); }
  else {
    const algo = algoSel.value;
    if(algo === 'dijkstra'){ log('Use Setup to run Dijkstra auto sequence (Play works for Kruskal).'); return; }
    playBtn.textContent = 'Pause';
    playTimer = setInterval(()=> stepOnce(), Math.max(200, parseInt(speedRange.value)));
    log('Autoplay Kruskal started');
  }
}

// show full shortest instantly (if Dijkstra computed prev)
let lastPrev = null;
function showFullPath(){
  const algo = algoSel.value;
  if(algo !== 'dijkstra'){ log('Full-path instant only for Dijkstra'); return; }
  // recompute dijkstra prev quickly
  const start = startSel.value, end = endSel.value;
  if(!start || !end) { log('Select start & end'); return; }
  const {dist, prev} = computeDijkstra(start,end);
  if(!isFinite(dist[end])){ log('No path'); return; }
  lastPrev = prev;
  // reconstruct shortest path nodes
  const nodesList = [];
  let cur = end;
  while(cur){ nodesList.push(cur); cur = prev[cur]; }
  nodesList.reverse();
  drawPathHighlights(nodesList, 'lime');
  log('Shortest path shown instantly.');
}

// reset
function resetGraph(){
  nodes = {}; edges = {}; nodeCount = 0; selectedForEdge = null;
  kruskalGen = null; lastPrev = null;
  explainBox.innerHTML = '';
  updateSelectors(); drawGraph();
}

function clearLog(){ explainBox.innerHTML=''; }

// Presets
function loadPreset(which){
  resetGraph();
  const cx = canvas.width/2, cy = canvas.height/2;
  if(which === 'triangle'){
    nodes = {A:[cx-130,cy+60], B:[cx,cy-90], C:[cx+130,cy+60]};
    edges = {A:[{v:'B',w:4},{v:'C',w:1}], B:[{v:'A',w:4},{v:'C',w:2}], C:[{v:'A',w:1},{v:'B',w:2}]};
    nodeCount = 3;
  } else if(which === 'square'){
    nodes = {A:[cx-140,cy-80], B:[cx+140, cy-80], C:[cx+140, cy+80], D:[cx-140, cy+80]};
    edges = {A:[{v:'B',w:3},{v:'D',w:1}], B:[{v:'A',w:3},{v:'C',w:4}], C:[{v:'B',w:4},{v:'D',w:2}], D:[{v:'A',w:1},{v:'C',w:2}]};
    nodeCount = 4;
  } else if(which === 'chain'){
    nodes = {A:[cx-280,cy], B:[cx-100,cy], C:[cx+80,cy], D:[cx+260,cy]};
    edges = {A:[{v:'B',w:5}], B:[{v:'A',w:5},{v:'C',w:3}], C:[{v:'B',w:3},{v:'D',w:6}], D:[{v:'C',w:6}]};
    nodeCount = 4;
  } else if(which === 'random'){
    nodes = {}; edges = {}; nodeCount = 0;
    for(let i=0;i<6;i++){
      const n = String.fromCharCode(65 + nodeCount++);
      const ang = i * (Math.PI*2/6);
      nodes[n] = [cx + Math.cos(ang)*160, cy + Math.sin(ang)*120];
      edges[n] = [];
    }
    const keys = Object.keys(nodes);
    for(let i=0;i<keys.length;i++){
      for(let j=i+1;j<keys.length;j++){
        if(Math.random() < 0.45){
          const w = Math.floor(Math.random()*9)+1;
          edges[keys[i]].push({v:keys[j], w});
          edges[keys[j]].push({v:keys[i], w});
        }
      }
    }
  } else if(which === 'star'){
    nodes = {}; edges = {}; nodeCount = 0;
    const center = 'A'; nodes['A']=[cx,cy]; edges['A']=[];
    nodeCount=1;
    for(let i=0;i<5;i++){
      const n = String.fromCharCode(65 + nodeCount++);
      const ang = i * (Math.PI*2/5);
      nodes[n] = [cx + Math.cos(ang)*160, cy + Math.sin(ang)*120];
      edges[n] = [];
      const w = Math.floor(Math.random()*8)+1;
      edges['A'].push({v:n,w}); edges[n].push({v:'A',w});
    }
  } else if(which === 'complete'){
    nodes = {}; edges = {}; nodeCount = 0;
    const N = 6;
    for(let i=0;i<N;i++){ const n=String.fromCharCode(65+nodeCount++); nodes[n]=[cx+Math.cos(i*2*Math.PI/N)*160, cy+Math.sin(i*2*Math.PI/N)*120]; edges[n]=[]; }
    const keys = Object.keys(nodes);
    for(let i=0;i<keys.length;i++){
      for(let j=i+1;j<keys.length;j++){
        const w = Math.floor(Math.random()*9)+1;
        edges[keys[i]].push({v:keys[j], w}); edges[keys[j]].push({v:keys[i], w});
      }
    }
  } else if(which === 'hexagon'){
    nodes = {}; edges = {}; nodeCount = 0;
    for(let i=0;i<6;i++){ const n = String.fromCharCode(65+nodeCount++); const ang = i*(Math.PI*2/6); nodes[n] = [cx + Math.cos(ang)*180, cy + Math.sin(ang)*120]; edges[n]=[]; }
    const keys = Object.keys(nodes);
    for(let i=0;i<keys.length;i++){
      const a = keys[i], b = keys[(i+1)%keys.length]; const w = Math.floor(Math.random()*9)+1;
      edges[a].push({v:b,w}); edges[b].push({v:a,w});
    }
  }
  updateSelectors(); drawGraph();
  log(`Loaded preset: ${which}`);
}

/* ============================
   All-paths Dijkstra flow
   ============================ */
async function runDijkstraShowLMSS(start, end){
  clearLog();
  log(`Computing Dijkstra & enumerating paths from ${start} to ${end}...`);
  // Check basic
  if(!nodes[start] || !nodes[end]){ log('invalid nodes'); return; }

  // enumerate all simple paths
  const paths = enumerateAllSimplePaths(start, end);
  if(paths.length === 0){ log('No paths between start and end'); return; }
  if(paths.length >= MAX_PATHS) log(`Found >=${MAX_PATHS} paths (capped). Showing available results.`);
  // compute picks
  const picks = pickLMS(paths);
  log(`Paths found: ${paths.length}. Long=${picks.long? picks.long.weight:'N/A'} Mid=${picks.mid? picks.mid.weight:'N/A'} Short=${picks.short?picks.short.weight:'N/A'}`);
  // animate: Long (red), Mid (orange), Short (green)
  await animatePathSequence(picks);
}

async function setupRun(){
  clearLog();
  const algo = algoSel.value;
  if(algo === 'dijkstra'){
    const start = startSel.value, end = endSel.value;
    if(!start || !end){ log('Select Start and End'); return; }
    await runDijkstraShowLMSS(start, end);
  } else {
    log('Kruskal setup: use Step / Play to progress.');
    kruskalGen = kruskalGenerator();
    drawGraph();
  }
}

// initial tiny demo preset
loadPresetBtn.click = null;
loadPresetBtn.addEventListener('click', ()=> loadPreset(presetSel.value));
presetSel.value = 'triangle'; loadPreset('triangle');

drawGraph();
</script>
</body>
</html>





