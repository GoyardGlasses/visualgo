<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dijkstra Visualizer (Graph + Table + Matrix)</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    table, th, td { border: 1px solid black; border-collapse: collapse; padding: 6px; }
    #explainBox { border: 1px solid black; padding: 10px; margin-top: 10px; min-height: 60px; background: #f9f9f9; }
    canvas { border: 1px solid black; margin-top: 10px; }
  </style>
</head>
<body>
  <h2>Dijkstra’s Algorithm Visualizer</h2>

  <!-- Input Section -->
  <h3>Graph Input</h3>
  <label>Number of Vertices:</label>
  <input type="number" id="numVertices" min="2" value="4"><br><br>

  <label>Number of Edges:</label>
  <input type="number" id="numEdges" min="1" value="5"><br><br>

  <button onclick="makeEdgeInputs()">Generate Edge Inputs</button>
  <div id="edgeInputs"></div>
  <button onclick="buildGraph()">Build Graph</button>

  <!-- Adjacency Matrix -->
  <h3>Adjacency Matrix</h3>
  <div id="matrix"></div>

  <!-- Distance Table -->
  <h3>Distance Table</h3>
  <table id="distTable">
    <thead>
      <tr><th>Step</th><th>Chosen Node</th><th>Distances (d[])</th><th>Parents (π[])</th></tr>
    </thead>
    <tbody></tbody>
  </table>

  <!-- Explanation -->
  <h3>Step Explanation</h3>
  <div id="explainBox">Build a graph and click "Step".</div>

  <!-- Graph Visualization -->
  <h3>Graph Visualization</h3>
  <canvas id="canvas" width="600" height="400"></canvas>

  <!-- Controls -->
  <button onclick="resetDijkstra()">Reset</button>
  <button onclick="runStep()">Step</button>

  <script>
    let V = 0, E = 0;
    let adjMatrix = [];
    let dist = [], parent = [], visited = [];
    let pq = [];
    let step = 0;
    let edges = [];
    let canvas = document.getElementById("canvas");
    let ctx = canvas.getContext("2d");

    // Generate edge input fields
    function makeEdgeInputs() {
      V = parseInt(document.getElementById("numVertices").value);
      E = parseInt(document.getElementById("numEdges").value);
      let html = "<h4>Enter Edges (u v w)</h4><p>(Use A,B,C... for vertices)</p>";
      for (let i = 0; i < E; i++) {
        html += "Edge " + (i+1) + ": " +
          "<input size='1' id='u"+i+"' placeholder='u'>" +
          "<input size='1' id='v"+i+"' placeholder='v'>" +
          "<input size='2' id='w"+i+"' placeholder='w'><br>";
      }
      document.getElementById("edgeInputs").innerHTML = html;
    }

    // Build adjacency matrix
    function buildGraph() {
      adjMatrix = Array.from({length:V},()=>Array(V).fill("∞"));
      edges = [];
      for (let i=0; i<V; i++) adjMatrix[i][i]=0;
      for (let i=0; i<E; i++) {
        let u = document.getElementById("u"+i).value.toUpperCase().charCodeAt(0)-65;
        let v = document.getElementById("v"+i).value.toUpperCase().charCodeAt(0)-65;
        let w = parseInt(document.getElementById("w"+i).value);
        adjMatrix[u][v]=w;
        adjMatrix[v][u]=w; // undirected
        edges.push({u,v,w,color:"black"});
      }
      updateMatrix();
      resetDijkstra();
      drawGraph();
    }

    // Show adjacency matrix
    function updateMatrix() {
      let html="<table><tr><th></th>";
      for (let i=0; i<V; i++) html+="<th>"+String.fromCharCode(65+i)+"</th>";
      html+="</tr>";
      for (let i=0; i<V; i++) {
        html+="<tr><th>"+String.fromCharCode(65+i)+"</th>";
        for (let j=0; j<V; j++) html+="<td>"+adjMatrix[i][j]+"</td>";
        html+="</tr>";
      }
      html+="</table>";
      document.getElementById("matrix").innerHTML=html;
    }

    // Reset Dijkstra
    function resetDijkstra() {
      dist=Array(V).fill(Infinity);
      parent=Array(V).fill("-");
      visited=Array(V).fill(false);
      dist[0]=0; // source = A
      pq=[0];
      step=0;
      document.querySelector("#distTable tbody").innerHTML="";
      document.getElementById("explainBox").innerHTML="Graph ready. Press Step.";
      edges.forEach(e=>e.color="black");
      drawGraph();
    }

    // Run one step
    function runStep() {
      if (pq.length==0) { 
        document.getElementById("explainBox").innerHTML="✅ Algorithm finished. Green edges show the shortest path tree.";
        highlightFinalTree();
        return;
      }
      let u = pq.reduce((a,b)=>dist[a]<dist[b]?a:b);
      pq = pq.filter(x=>x!=u);
      if (visited[u]) return runStep();
      visited[u]=true;

      let exp = "Step "+(++step)+": Choosing node "+String.fromCharCode(65+u)+" with dist="+dist[u]+"<br>";

      for (let v=0; v<V; v++) {
        if (adjMatrix[u][v]!="∞" && !visited[v]) {
          let candidate = dist[u]+parseInt(adjMatrix[u][v]);
          if (candidate < dist[v]) {
            exp += "✔ Updating "+String.fromCharCode(65+v)+": candidate="+candidate+" < current="+dist[v]+" → parent="+String.fromCharCode(65+u)+"<br>";
            dist[v]=candidate;
            parent[v]=String.fromCharCode(65+u);
            pq.push(v);
            colorEdge(u,v,"green");
          } else if (candidate === dist[v]) {
            exp += "⚖ Tie on "+String.fromCharCode(65+v)+": candidate="+candidate+" == current="+dist[v]+" (keep existing parent)<br>";
            colorEdge(u,v,"orange");
          } else {
            exp += "✘ Rejecting "+String.fromCharCode(65+v)+": candidate="+candidate+" ≥ current="+dist[v]+"<br>";
            colorEdge(u,v,"red");
          }
        }
      }

      let row="<tr><td>"+step+"</td><td>"+String.fromCharCode(65+u)+"</td><td>"+dist.map(d=>d==Infinity?"∞":d).join(", ")+"</td><td>"+parent.join(", ")+"</td></tr>";
      document.querySelector("#distTable tbody").innerHTML+=row;

      document.getElementById("explainBox").innerHTML=exp;
      drawGraph();
    }

    // Color an edge
    function colorEdge(u,v,color) {
      edges.forEach(e=>{
        if ((e.u===u && e.v===v)||(e.u===v && e.v===u)) e.color=color;
      });
    }

    // Highlight final shortest path tree
    function highlightFinalTree() {
      for (let v=1; v<V; v++) {
        if (parent[v]!=="-") {
          let u = parent[v].charCodeAt(0)-65;
          colorEdge(u,v,"green");
        }
      }
      drawGraph();
    }

    // Draw graph
    function drawGraph() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      let R=150, cx=300, cy=200;
      let positions=[];
      for (let i=0;i<V;i++) {
        let angle=2*Math.PI*i/V;
        positions.push({x:cx+R*Math.cos(angle), y:cy+R*Math.sin(angle)});
      }
      // draw edges
      edges.forEach(e=>{
        let u=positions[e.u], v=positions[e.v];
        ctx.beginPath();
        ctx.strokeStyle=e.color;
        ctx.moveTo(u.x,u.y);
        ctx.lineTo(v.x,v.y);
        ctx.stroke();
        ctx.fillStyle="black";
        ctx.fillText(e.w,(u.x+v.x)/2,(u.y+v.y)/2);
      });
      // draw nodes
      for (let i=0;i<V;i++) {
        ctx.beginPath();
        ctx.arc(positions[i].x,positions[i].y,20,0,2*Math.PI);
        ctx.fillStyle="lightblue";
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle="black";
        ctx.fillText(String.fromCharCode(65+i),positions[i].x-5,positions[i].y+5);
      }
    }
  </script>
</body>
</html>










